--[[
SCRIPT_PATHS
  Self: ServerScriptService/TagServer
  Requires:
    - ReplicatedStorage/Shared/GameConfig
    - ServerScriptService/Modules/TagService
  Remotes:
    - ReplicatedStorage/Remotes/FireRay (RemoteEvent, name from GameConfig.RemoteNames.FireRay)
    - ReplicatedStorage/Remotes/State (RemoteEvent, name from GameConfig.RemoteNames.State)
  UsesConfigKeys:
    - Tagging.ToolName
    - Tagging.StartAmmo
    - Tagging.MaxAmmo
    - Tagging.FireRateRPM
    - Tagging.CooldownSeconds
    - Tagging.AutoReload
    - Tagging.ReloadPerShellSeconds
    - Tagging.LockDuringReload
    - Tagging.OriginOffset
    - Tagging.MaxRange
    - Tagging.OneTagPerShot
    - RemoteNames.FireRay
    - RemoteNames.State
]]

-- ServerScriptService/TagServer.server.lua  
-- Server-side tag validation and tool state management (updated for new system)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local GameConfig = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Shared"):WaitForChild("GameConfig"))

-- Import TagService to ensure it's initialized
local TagService = require(ServerScriptService.Modules:WaitForChild("TagService"))

-- Config helper
local function Cfg(path)
	local keys = string.split(path, ".")
	local value = GameConfig
	for _, key in ipairs(keys) do
		value = value[key]
		if not value then break end
	end
	return value
end

-- Wait for remotes (created by GameStartup)
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local fireRemote = remotes:WaitForChild(Cfg("RemoteNames.FireRay"))
local stateRemote = remotes:WaitForChild(Cfg("RemoteNames.State"))

-- Per-player tool state tracking
type ToolState = {
	ammo: number,
	lastShot: number,
	reloading: boolean,
	emptyNotified: boolean,
	reloadToken: number
}

local stateByUserId: {[number]: ToolState} = {}

-- Get or create player tool state
local function getState(player: Player): ToolState
	local state = stateByUserId[player.UserId]
	if not state then
		state = {
			ammo = Cfg("Tagging.StartAmmo"),
			lastShot = 0,
			reloading = false,
			emptyNotified = false,
			reloadToken = 0
		}
		stateByUserId[player.UserId] = state
	end
	return state
end

-- Send state update to client
local function sendState(player: Player, payload: table)
	stateRemote:FireClient(player, payload)
end

-- Get authoritative firing origin
local function computeOriginServer(player: Player): Vector3?
	local character = player.Character
	if not character then return nil end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end

	local offset = Cfg("Tagging.OriginOffset")
	return humanoidRootPart.Position + humanoidRootPart.CFrame:VectorToWorldSpace(
		Vector3.new(offset[1], offset[2], offset[3])
	)
end

-- Validate if target can be hit
local function isValidTarget(shooter: Player, hitModel: Instance?): boolean
	if not hitModel then return false end

	local humanoid = hitModel:FindFirstChild("Humanoid")
	if not humanoid then return false end

	local hitPlayer = Players:GetPlayerFromCharacter(hitModel)
	if not hitPlayer then return false end
	if hitPlayer == shooter then return false end

	return true
end

-- Process raycast hit and report to TagService
local function handleRaycastHit(shooter: Player, result: RaycastResult): boolean
	local hitPart = result.Instance
	if not hitPart then return false end

	local model = hitPart:FindFirstAncestorOfClass("Model")
	if not isValidTarget(shooter, model) then return false end

	local hitPlayer = Players:GetPlayerFromCharacter(model)
	if hitPlayer then
		-- Use TagService to validate and report the tag
		return TagService.ReportTag(shooter, hitPlayer)
	end

	return false
end

-- Reload system - single token to prevent overlapping reloads
local function startShellReload(player: Player, state: ToolState)
	if state.ammo >= Cfg("Tagging.MaxAmmo") then
		if state.reloading then
			state.reloading = false
			sendState(player, {reloading = false, ammo = state.ammo, max = Cfg("Tagging.MaxAmmo")})
		end
		return
	end

	if state.reloading then return end -- Already reloading

	state.reloading = true
	state.reloadToken = state.reloadToken + 1
	local myToken = state.reloadToken

	sendState(player, {reloading = true, ammo = state.ammo, max = Cfg("Tagging.MaxAmmo")})

	task.spawn(function()
		while true do
			-- Check if we should stop (player left or reload interrupted)
			if state.reloadToken ~= myToken or not player.Parent then break end
			if state.ammo >= Cfg("Tagging.MaxAmmo") then break end

			task.wait(Cfg("Tagging.ReloadPerShellSeconds"))

			-- Check again after wait
			if state.reloadToken ~= myToken or not player.Parent then break end
			if state.ammo >= Cfg("Tagging.MaxAmmo") then break end

			-- Add one shell
			state.ammo = state.ammo + 1
			state.emptyNotified = false
			sendState(player, {reloading = true, ammo = state.ammo, max = Cfg("Tagging.MaxAmmo")})
		end

		-- Finalize reload if we're still the active reload
		if state.reloadToken == myToken then
			state.reloading = false
			sendState(player, {reloading = false, ammo = state.ammo, max = Cfg("Tagging.MaxAmmo")})
		end
	end)
end

-- Handle fire requests from clients
fireRemote.OnServerEvent:Connect(function(shooter: Player, _originFromClient: Vector3?, unitDirs: {Vector3}?)
	if typeof(unitDirs) ~= "table" then return end
	if #unitDirs < 1 or #unitDirs > 64 then return end

	local character = shooter.Character
	if not character then return end

	local state = getState(shooter)

	-- Fire rate check with proper timestamps
	local now = os.clock()
	local fireRateRPM = Cfg("Tagging.FireRateRPM")
	local cooldown = (fireRateRPM > 0) and (60 / fireRateRPM) or Cfg("Tagging.CooldownSeconds")
	local timeSinceLastShot = now - state.lastShot

	if timeSinceLastShot < cooldown then
		sendState(shooter, {error = "cooldown", timeLeft = cooldown - timeSinceLastShot, ammo = state.ammo})
		return
	end

	-- Ammo check
	if state.ammo <= 0 then
		if state.reloading then
			sendState(shooter, {error = "reloading", ammo = state.ammo, max = Cfg("Tagging.MaxAmmo")})
		else
			if not state.emptyNotified then
				sendState(shooter, {error = "empty", ammo = state.ammo})
				state.emptyNotified = true
			end
			if Cfg("Tagging.AutoReload") then
				startShellReload(shooter, state)
			end
		end
		return
	end

	-- Consume ammo and record shot time
	state.ammo = state.ammo - 1
	state.lastShot = now
	state.emptyNotified = false

	-- Authoritative raycast
	local origin = computeOriginServer(shooter)
	if not origin then
		state.ammo = state.ammo + 1 -- Refund if something went wrong
		return
	end

	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.FilterDescendantsInstances = {character}

	local hitPlayers = {}
	local maxRange = Cfg("Tagging.MaxRange")
	local oneTagPerShot = Cfg("Tagging.OneTagPerShot") or false

	-- Process each ray
	for _, direction in pairs(unitDirs) do
		if typeof(direction) ~= "Vector3" then continue end

		local raycastResult = workspace:Raycast(origin, direction.Unit * math.min(maxRange, 2000), raycastParams)
		if raycastResult then
			local hitPart = raycastResult.Instance
			if hitPart then
				local model = hitPart:FindFirstAncestorOfClass("Model")
				if isValidTarget(shooter, model) then
					local hitPlayer = Players:GetPlayerFromCharacter(model)
					if hitPlayer and not table.find(hitPlayers, hitPlayer) then
						table.insert(hitPlayers, hitPlayer)
						if oneTagPerShot then
							break -- Stop after first potential target
						end
					end
				end
			end
		end
	end

	-- Process all hits through TagService
	local tagged = false
	for _, victim in pairs(hitPlayers) do
		if TagService.ValidateAndApplyTag(shooter, victim) then
			tagged = true
			if oneTagPerShot then
				break -- Stop after first successful tag
			end
		end
	end

	-- Notify client of successful fire
	sendState(shooter, {ok = true, ammo = state.ammo, tagged = tagged})

	-- Start reload if auto-reload enabled and not full
	if Cfg("Tagging.AutoReload") and state.ammo < Cfg("Tagging.MaxAmmo") then
		startShellReload(shooter, state)
	end
end)

-- Handle tool equipping - reset state
local function onToolEquipped(tool: Tool, player: Player)
	local state = getState(player)
	state.ammo = Cfg("Tagging.StartAmmo")
	state.lastShot = 0
	state.reloading = false
	state.emptyNotified = false
	state.reloadToken = state.reloadToken + 1 -- Cancel any existing reload

	sendState(player, {ammo = state.ammo, reloading = false, max = Cfg("Tagging.MaxAmmo")})

	if Cfg("Tagging.AutoReload") and state.ammo < Cfg("Tagging.MaxAmmo") then
		startShellReload(player, state)
	end
end

-- Monitor for tool equipping
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") and child.Name == Cfg("Tagging.ToolName") then
				onToolEquipped(child, player)
			end
		end)
	end)
end)

-- Cleanup on player removal
Players.PlayerRemoving:Connect(function(player)
	stateByUserId[player.UserId] = nil
end)

print("TagServer initialized with new game system")
