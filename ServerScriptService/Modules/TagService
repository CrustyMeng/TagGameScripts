--[[
SCRIPT_PATHS
  Self: ServerScriptService/Modules/TagService
  Requires:
    - ReplicatedStorage/Shared/GameConfig
    - ReplicatedStorage/Shared/Movement/RaycastUtil
    - ServerScriptService/Modules/GameDirector
    - ServerScriptService/Modules/TeamsService
  Remotes:
    - ReplicatedStorage/Remotes/ReportTag (RemoteEvent, name from GameConfig.RemoteNames.ReportTag)
  UsesConfigKeys:
    - Debug.Enabled
    - Debug.Channels
    - Tagging.MaxRange
    - Tagging.EnableLOS
    - Tagging.LineOfSight.*
    - Tagging.OneTagPerShot
    - Teams.FriendlyFire
    - RemoteNames.ReportTag
    - Folders.Remotes
]]

-- ServerScriptService/Modules/TagService.lua

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- Shared layout under ReplicatedStorage.Modules.Shared.*
local GameConfig  = require(ReplicatedStorage.Modules.Shared.GameConfig)
local RaycastUtil = require(ReplicatedStorage.Modules.Shared.Movement.RaycastUtil)

local GameDirector = require(ServerScriptService.Modules.GameDirector)
local TeamsService  = require(ServerScriptService.Modules.TeamsService)

local TagService = {}

local taggedEvent = Instance.new("BindableEvent")
TagService.Tagged = taggedEvent.Event

-- AUTHORITATIVE FREEZE STATE (server-only)
local frozenPlayers: {[Player]: boolean} = {}

local function Cfg(path)
	local node = GameConfig
	for seg in string.gmatch(path, "[^%.]+") do
		node = node and node[seg]
	end
	return node
end

local function debugLog(message)
	if GameConfig.Debug and GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels or {}, "Tag") then
		print("[Tag] " .. message)
	end
end

-- SERVER AUTHORITY: Freeze a player
function TagService.FreezePlayer(player: Player)
	if not player or not player.Parent then return end

	frozenPlayers[player] = true

	local character = player.Character
	if not character then 
		debugLog("SERVER: Marked " .. player.Name .. " as frozen (no character yet)")
		return 
	end

	local humanoid = character:FindFirstChild("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")

	if humanoid then
		-- Store original values as attributes
		if humanoid:GetAttribute("OriginalWalkSpeed") == nil then
			humanoid:SetAttribute("OriginalWalkSpeed", humanoid.WalkSpeed)
		end
		if humanoid:GetAttribute("OriginalJumpPower") == nil then
			humanoid:SetAttribute("OriginalJumpPower", humanoid.JumpPower)
		end

		-- Apply freeze
		humanoid.WalkSpeed = 0
		humanoid.JumpPower = 0
	end

	-- Create visual indicator for clients (server authority)
	local frozenValue = character:FindFirstChild("IsFrozen")
	if not frozenValue then
		frozenValue = Instance.new("BoolValue")
		frozenValue.Name = "IsFrozen"
		frozenValue.Parent = character
	end
	frozenValue.Value = true

	-- Anchor for extra security if configured
	if rootPart and Cfg("FreezeTag.FreezeMovement") then
		rootPart.Anchored = true
	end

	debugLog("SERVER: Froze " .. player.Name)
end

-- SERVER AUTHORITY: Unfreeze a player
function TagService.UnfreezePlayer(player: Player)
	if not player or not player.Parent then return end

	-- EXPLICITLY clear frozen state FIRST
	frozenPlayers[player] = nil

	local character = player.Character
	if not character then 
		debugLog("SERVER: Cleared frozen state for " .. player.Name .. " (no character)")
		return 
	end

	local humanoid = character:FindFirstChild("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")

	if humanoid then
		-- Restore movement
		local originalWalkSpeed = humanoid:GetAttribute("OriginalWalkSpeed")
		local originalJumpPower = humanoid:GetAttribute("OriginalJumpPower")

		humanoid.WalkSpeed = originalWalkSpeed or 16
		humanoid.JumpPower = originalJumpPower or 50

		humanoid:SetAttribute("OriginalWalkSpeed", nil)
		humanoid:SetAttribute("OriginalJumpPower", nil)
	end

	-- Remove frozen indicator
	local frozenValue = character:FindFirstChild("IsFrozen")
	if frozenValue then
		frozenValue:Destroy()
	end

	-- Unanchor
	if rootPart then
		rootPart.Anchored = false
	end

	debugLog("SERVER: Unfroze " .. player.Name)
end

-- Check if player is frozen (server authority) - SIMPLIFIED VERSION
function TagService.IsPlayerFrozen(player: Player): boolean
	-- Server state is the single source of truth
	local serverFrozen = frozenPlayers[player] == true

	-- Only validate character state during actual gameplay, not during respawning
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		local frozenValue = player.Character:FindFirstChild("IsFrozen")
		if frozenValue and frozenValue.Value ~= serverFrozen then
			-- Fix mismatch silently during gameplay
			frozenValue.Value = serverFrozen
		elseif not frozenValue and serverFrozen then
			-- Create missing frozen indicator
			local newFrozenValue = Instance.new("BoolValue")
			newFrozenValue.Name = "IsFrozen"
			newFrozenValue.Value = true
			newFrozenValue.Parent = player.Character
		end
	end

	return serverFrozen
end

-- Unfreeze all players (server authority)
function TagService.UnfreezeAllPlayers()
	local playerList = {}
	for player, _ in pairs(frozenPlayers) do
		table.insert(playerList, player)
	end

	-- Clear the table first
	frozenPlayers = {}

	-- Then unfreeze each player
	for _, player in pairs(playerList) do
		TagService.UnfreezePlayer(player)
	end

	debugLog("SERVER: Unfroze all players (" .. #playerList .. " total)")
end

-- Handle respawn - reapply frozen state
local function onCharacterAdded(player: Player)
	if TagService.IsPlayerFrozen(player) then
		task.wait(0.1) -- Ensure character is loaded
		TagService.FreezePlayer(player)
	end
end

-- Set up event handlers
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function()
		onCharacterAdded(player)
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	frozenPlayers[player] = nil
	debugLog("SERVER: Cleaned up frozen state for " .. player.Name)
end)

-- Prefer Humanoid.RootPart (movement systems often swap/rename root)
local function getRootPart(char)
	if not char then return nil end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum and hum.RootPart then return hum.RootPart end
	return char:FindFirstChild("HumanoidRootPart")
end

local function getAimPart(char)
	if not char then return nil end
	return char:FindFirstChild("Head") or getRootPart(char)
end

local function hitCountsAsVictim(hitInstance, victimChar)
	if not (hitInstance and victimChar) then return false end
	if hitInstance:IsDescendantOf(victimChar) then
		return true
	end
	local acc = hitInstance:FindFirstAncestorOfClass("Accessory")
	if acc and acc:IsDescendantOf(victimChar) then
		return true
	end
	local arp = hitInstance:IsA("BasePart") and hitInstance.AssemblyRootPart or nil
	if arp and arp:IsDescendantOf(victimChar) then
		return true
	end
	return false
end

local function isSoftBlocker(part)
	if not part or not part:IsA("BasePart") then return false end
	local ignoreNonCollidable = Cfg("Tagging.LineOfSight.IgnoreNonCollidable")
	local transpThresh = Cfg("Tagging.LineOfSight.TransparencyThreshold") or 0
	local ignoreNames = Cfg("Tagging.LineOfSight.IgnoreNames") or {}
	local ignoreContains = Cfg("Tagging.LineOfSight.IgnoreNameContains") or {}

	if ignoreNonCollidable and part.CanCollide == false then
		return true
	end
	if transpThresh > 0 and part.Transparency >= transpThresh then
		return true
	end
	for _, n in ipairs(ignoreNames) do
		if part.Name == n then
			return true
		end
	end
	local lname = string.lower(part.Name)
	for _, sub in ipairs(ignoreContains) do
		if lname:find(string.lower(sub), 1, true) then
			return true
		end
	end
	return false
end

local function buildAttackerBlacklist(attackerChar)
	local list = { attackerChar }
	local commonNames = { "Hitbox", "CharacterHitbox", "Collision", "Collider", "RootHitbox", "ProxyRoot" }
	for _, nm in ipairs(commonNames) do
		local found = attackerChar:FindFirstChild(nm, true)
		if found then table.insert(list, found) end
	end
	for _, d in ipairs(attackerChar:GetDescendants()) do
		if d:IsA("BasePart") and (d.Name == "Handle" or d.Name:lower():find("handle")) then
			table.insert(list, d)
		end
	end
	return list
end

-- SINGLE RAY with robust guards. Treat (hit and hit.Instance==nil) as clear (no blocker).
local function castClear(originPart, targetPos, attackerChar, victimChar)
	local origin = originPart.Position
	local vec = (targetPos - origin)
	local dist = vec.Magnitude
	if dist <= 0 then return true end

	local hit = RaycastUtil:Cast(originPart, vec.Unit, dist, {
		blacklist = buildAttackerBlacklist(attackerChar),
		visualize = GameConfig.Debug and table.find(GameConfig.Debug.Channels or {}, "Raycast") ~= nil
	})

	-- No result at all: clear.
	if not hit then
		return true
	end

	-- Some RaycastUtil impls may return a table missing Instance. Treat as clear to avoid false blocks.
	local inst = hit.Instance
	if inst == nil then
		if GameConfig.Debug and GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels or {}, "Tag") then
			print("[Tag][LOS] ray result without Instance; treating as clear")
		end
		return true
	end

	-- Clear if we hit the victim (character or accessories)
	if hitCountsAsVictim(inst, victimChar) then
		return true
	end

	-- Ignore soft blockers (non-collidable/transparent/name-matched)
	if isSoftBlocker(inst) then
		return true
	end

	if GameConfig.Debug and GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels or {}, "Tag") then
		local nameSafe = (typeof(inst.GetFullName) == "function") and inst:GetFullName() or tostring(inst)
		local canCollide = (typeof(inst) == "Instance" and inst:IsA("BasePart")) and inst.CanCollide or "?"
		local transp = (typeof(inst) == "Instance" and inst:IsA("BasePart")) and inst.Transparency or "?"
		print(("[Tag][LOS] blocked by %s (CanCollide=%s, Transparency=%s) @ %s")
			:format(nameSafe, tostring(canCollide), tostring(transp), tostring(hit.Position)))
	end
	return false
end

-- Triple-ray LOS
local function validateLineOfSight(attackerChar, victimChar)
	if not (GameConfig.Tagging and GameConfig.Tagging.EnableLOS) then
		return true
	end

	local aAim = getAimPart(attackerChar)
	local vHead = victimChar and victimChar:FindFirstChild("Head")
	local vRoot = getRootPart(victimChar)

	if not aAim or not (vHead or vRoot) then
		return false
	end

	local targets = {}
	if vHead then table.insert(targets, vHead.Position) end
	if vRoot then table.insert(targets, vRoot.Position + Vector3.new(0, 0.35, 0)) end
	if vHead then table.insert(targets, vHead.Position + Vector3.new(0, 0.2, 0)) end

	for _, t in ipairs(targets) do
		if castClear(aAim, t, attackerChar, victimChar) then
			return true
		end
	end
	return false
end

local function validateTag(attacker, victim)
	if GameDirector.GetState and GameDirector.GetState() ~= GameDirector.States.Match then
		return false, "Match not active"
	end

	if not attacker or not attacker.Parent then
		return false, "Invalid attacker"
	end
	if not victim or not victim.Parent then
		return false, "Invalid victim"
	end
	local aChar, vChar = attacker.Character, victim.Character
	if not (aChar and vChar) then
		return false, "Missing character"
	end

	local aRoot = getRootPart(aChar)
	local vRoot = getRootPart(vChar)
	if not (aRoot and vRoot) then
		return false, "Missing RootPart"
	end

	local maxRange = (GameConfig.Tagging and GameConfig.Tagging.MaxRange) or 30
	local distance = (aRoot.Position - vRoot.Position).Magnitude
	if distance > maxRange then
		return false, ("Too far (%d > %d)"):format(math.floor(distance), maxRange)
	end

	local attackerRole = TeamsService.GetPlayerRole and TeamsService.GetPlayerRole(attacker) or "Player"
	local victimRole   = TeamsService.GetPlayerRole and TeamsService.GetPlayerRole(victim)   or "Player"

	if attackerRole ~= "Tagger" then
		return false, "Only taggers can tag"
	end

	if victimRole ~= "Player" then
		return false, "Can only tag players"
	end

	-- Check if already frozen - server state is authoritative
	if TagService.IsPlayerFrozen(victim) then
		return false, "Target already frozen"
	end

	local allowFriendly = (GameConfig.Teams and GameConfig.Teams.FriendlyFire) or false
	if (not allowFriendly) and (attackerRole == victimRole) then
		return false, "Friendly fire disabled"
	end

	if not validateLineOfSight(aChar, vChar) then
		return false, "No line of sight"
	end

	return true
end

function TagService.ValidateAndApplyTag(attacker, victim, payload)
	local valid, reason = validateTag(attacker, victim)
	if not valid then
		debugLog(("Tag rejected: %s → %s (%s)"):format(attacker and attacker.Name or "?", victim and victim.Name or "?", reason or "unknown"))
		return false
	end

	debugLog(("Tag confirmed: %s → %s"):format(attacker.Name, victim.Name))

	-- SERVER AUTHORITY: Apply freeze
	TagService.FreezePlayer(victim)

	-- Fire event for game modes
	taggedEvent:Fire(attacker, victim, payload)
	return true
end

function TagService.ReportTag(attacker, victim, payload)
	return TagService.ValidateAndApplyTag(attacker, victim, payload)
end

-- Multi-shot handling with OneTagPerShot option
function TagService.ProcessMultipleHits(attacker, victims, payload)
	local oneTagPerShot = Cfg("Tagging.OneTagPerShot") or false
	local hitCount = 0

	for _, victim in ipairs(victims) do
		if TagService.ValidateAndApplyTag(attacker, victim, payload) then
			hitCount = hitCount + 1
			if oneTagPerShot then
				break -- Stop after first valid hit
			end
		end
	end

	return hitCount
end

-- Initialize remote connection
do
	local remotesFolderName = (GameConfig.Folders and GameConfig.Folders.Remotes) or "Remotes"
	local remotes = ReplicatedStorage:WaitForChild(remotesFolderName)
	if remotes then
		local reportName = (GameConfig.RemoteNames and GameConfig.RemoteNames.ReportTag) or "ReportTag"
		local tagRemote = remotes:WaitForChild(reportName)
		if tagRemote and tagRemote:IsA("RemoteEvent") then
			tagRemote.OnServerEvent:Connect(function(player, victimRef, payload)
				local victim = nil
				if typeof(victimRef) == "Instance" and victimRef:IsA("Player") then
					victim = victimRef
				elseif typeof(victimRef) == "number" then
					victim = Players:GetPlayerByUserId(victimRef)
				elseif typeof(victimRef) == "string" then
					victim = Players:FindFirstChild(victimRef)
				end
				if victim then
					TagService.ValidateAndApplyTag(player, victim, payload)
				end
			end)
		end
	end
end

return TagService
