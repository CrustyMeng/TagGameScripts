--[[
SCRIPT_PATHS
  Self: ServerScriptService/Modules/MatchLoop
  Requires:
    - ReplicatedStorage/Shared/GameConfig
    - ServerScriptService/Modules/GameDirector
    - ServerScriptService/Modules/HUDManager
    - ServerScriptService/Modules/MapService
    - ServerScriptService/Modules/TeamsService
    - ServerScriptService/Modules/LoadoutService
    - ServerScriptService/Modules/TagService
    - ServerScriptService/Modules/GameModeRegistry
  Remotes:
    - ReplicatedStorage/Remotes/RoundTime (RemoteEvent, name from GameConfig.RemoteNames.RoundTime)
    - ReplicatedStorage/Remotes/LobbyTimerUpdate (RemoteEvent, name from GameConfig.RemoteNames.LobbyTimerUpdate)
    - ReplicatedStorage/Remotes/LobbyVoteOpen (RemoteEvent, name from GameConfig.RemoteNames.LobbyVoteOpen)
    - ReplicatedStorage/Remotes/MidJoinClosed (RemoteEvent, name from GameConfig.RemoteNames.MidJoinClosed)
  UsesConfigKeys:
    - Lobby.MinPlayers
    - Lobby.LobbyCountdownSeconds
    - Lobby.AutoLoop
    - Match.RoundDurationSeconds
    - Match.HalftimeCutoffFraction
    - Round.PostGameSeconds
    - Round.AutoRestart
    - HUD.TimerUpdateHz
    - FeatureToggles.LobbyAutoLoop
    - FeatureToggles.MidJoin
    - FeatureToggles.MapVote
    - FeatureToggles.ModeVote
    - Voting.DefaultMode
    - Voting.DefaultMap
    - Voting.Enabled
    - Voting.MapOptions
    - Voting.ModeOptions
    - Voting.DurationSeconds
    - RemoteNames.*
]]

-- ServerScriptService/Modules/MatchLoop.lua
-- Timer management and match lifecycle (respawn-based movement)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local RunService = game:GetService("RunService")

local GameConfig = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Shared"):WaitForChild("GameConfig"))

local MatchLoop = {}

-- Timer state
local currentTimer = nil
local remoteEvent = nil
local lastBroadcast = 0

-- Mid-join state
local matchStartTime = 0
local halftimeCutoff = 0

-- Config helper
local function Cfg(path)
	local keys = string.split(path, ".")
	local value = GameConfig
	for _, key in ipairs(keys) do
		value = value[key]
		if not value then break end
	end
	return value
end

-- Timer handle type
type TimerHandle = {
	active: boolean,
	connection: RBXScriptConnection?,
	endTime: number,
	onDone: () -> ()
}

-- Debug logging
local function debugLog(message: string)
	if GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels, "Match") then
		print("[Match] " .. message)
	end
end

-- Ensure remote exists for HUD broadcasting
local function ensureRemote(remoteName: string): RemoteEvent
	local remotes = ReplicatedStorage:FindFirstChild("Remotes")
	if not remotes then
		remotes = Instance.new("Folder")
		remotes.Name = "Remotes"
		remotes.Parent = ReplicatedStorage
	end

	local remote = remotes:FindFirstChild(remoteName)
	if not remote then
		remote = Instance.new("RemoteEvent")
		remote.Name = remoteName
		remote.Parent = remotes
	end

	return remote
end

-- Start a timer (internal)
local function startTimer(seconds: number, onDone: (() -> ())?): TimerHandle
	-- Cancel existing timer
	if currentTimer then
		MatchLoop._CancelTimer(currentTimer)
	end

	if not remoteEvent then
		remoteEvent = ensureRemote(Cfg("RemoteNames.RoundTime"))
	end

	local handle: TimerHandle = {
		active = true,
		connection = nil,
		endTime = os.clock() + seconds,
		onDone = onDone or function() end
	}

	currentTimer = handle
	lastBroadcast = 0

	-- Start countdown loop (throttled by HUD.TimerUpdateHz)
	local updateInterval = 1 / Cfg("HUD.TimerUpdateHz")

	handle.connection = RunService.Heartbeat:Connect(function()
		if not handle.active then return end

		local now = os.clock()
		local remaining = math.max(0, handle.endTime - now)

		-- Throttle broadcasts
		if now - lastBroadcast >= updateInterval then
			lastBroadcast = now
			if remoteEvent then
				remoteEvent:FireAllClients(remaining)
			end
		end

		-- Timer complete
		if remaining <= 0 then
			MatchLoop._CancelTimer(handle)
			handle.onDone()
		end
	end)

	return handle
end

-- Cancel a timer (internal)
function MatchLoop._CancelTimer(handle: TimerHandle?)
	if not handle then return end

	handle.active = false

	if handle.connection then
		handle.connection:Disconnect()
		handle.connection = nil
	end

	if currentTimer == handle then
		currentTimer = nil
	end

	-- Send timer stopped signal
	if remoteEvent then
		remoteEvent:FireAllClients(0)
	end
end

-- Count current players
local function getCurrentPlayerCount(): number
	return #Players:GetPlayers()
end

-- Broadcast lobby status
local function broadcastLobbyStatus(timeLeft: number)
	local current = getCurrentPlayerCount()
	local minPlayers = Cfg("Lobby.MinPlayers")

	local lobbyTimerRemote = ensureRemote(Cfg("RemoteNames.LobbyTimerUpdate"))
	lobbyTimerRemote:FireAllClients({
		playersReady = current >= minPlayers,
		current = current,
		minPlayers = minPlayers,
		timeLeft = timeLeft
	})
end

-- Run lobby phase with auto-loop
function MatchLoop.RunLobbyPhase()
	local minPlayers = Cfg("Lobby.MinPlayers")
	local countdownSeconds = Cfg("Lobby.LobbyCountdownSeconds")
	local autoLoop = Cfg("Lobby.AutoLoop")

	debugLog("Starting lobby phase (min: " .. minPlayers .. ", countdown: " .. countdownSeconds .. "s)")

	-- Announce voting if enabled
	if Cfg("FeatureToggles.MapVote") or Cfg("FeatureToggles.ModeVote") then
		local voteRemote = ensureRemote(Cfg("RemoteNames.LobbyVoteOpen"))
		voteRemote:FireAllClients({
			maps = Cfg("Voting.MapOptions"),
			modes = Cfg("Voting.ModeOptions"),
			duration = Cfg("Voting.DurationSeconds")
		})
	end

	while true do
		local playerCount = getCurrentPlayerCount()
		debugLog("Lobby countdown starting - Players: " .. playerCount .. "/" .. minPlayers)

		-- Run countdown
		local countdownComplete = false
		startTimer(countdownSeconds, function()
			countdownComplete = true
		end)

		-- Update lobby status during countdown
		local statusUpdateInterval = 1
		local lastStatusUpdate = 0

		local statusConnection = RunService.Heartbeat:Connect(function()
			if not currentTimer or not currentTimer.active then return end

			local now = os.clock()
			if now - lastStatusUpdate >= statusUpdateInterval then
				lastStatusUpdate = now
				local timeLeft = math.max(0, currentTimer.endTime - now)
				broadcastLobbyStatus(timeLeft)
			end
		end)

		-- Wait for countdown to complete
		while not countdownComplete and currentTimer and currentTimer.active do
			task.wait(0.1)
		end

		statusConnection:Disconnect()

		-- Check if we have enough players
		playerCount = getCurrentPlayerCount()
		if playerCount >= minPlayers then
			debugLog("Enough players (" .. playerCount .. "/" .. minPlayers .. ") - starting match")
			return -- Exit lobby loop
		elseif not autoLoop then
			debugLog("Not enough players and auto-loop disabled")
			return
		else
			debugLog("Not enough players (" .. playerCount .. "/" .. minPlayers .. ") - restarting lobby")
			-- Loop continues
		end
	end
end

-- Begin match phase (RESPAWN to team pads)
function MatchLoop.BeginMatch(mode: string, map: string)
	debugLog("Starting match: " .. mode .. " on " .. map .. " (" .. Cfg("Match.RoundDurationSeconds") .. "s)")

	local GameDirector = require(script.Parent.GameDirector)
	local HUDManager = require(ServerScriptService.Modules.HUDManager)
	local MapService = require(ServerScriptService.Modules.MapService)

	GameDirector._ChangeState(GameDirector.States.Match)

	-- Track match timing for mid-join
	matchStartTime = os.clock()
	halftimeCutoff = matchStartTime + (Cfg("Match.RoundDurationSeconds") * Cfg("Match.HalftimeCutoffFraction"))

	-- Load the selected map (rebuild team pads)
	if not MapService.LoadMap(map) then
		warn("MatchLoop: Failed to load map '" .. map .. "', using current map if any")
	end

	-- Initialize mode FIRST (assigns teams)
	local GameModeRegistry = require(ServerScriptService.Modules.GameModeRegistry)
	GameModeRegistry.SetActiveMode(mode)

	-- Respawn everyone onto their unique team pads
	MapService.RespawnAllToMapTeams()

	-- Update HUD for match state
	HUDManager.OnStateChange("Match", mode, map)

	startTimer(Cfg("Match.RoundDurationSeconds"), function()
		MatchLoop.EndMatch("timeout")
	end)

	-- Handle mid-join closed at halftime
	task.spawn(function()
		local halftimeWait = Cfg("Match.RoundDurationSeconds") * Cfg("Match.HalftimeCutoffFraction")
		task.wait(halftimeWait)

		if Cfg("FeatureToggles.MidJoin") then
			local midJoinClosedRemote = ensureRemote(Cfg("RemoteNames.MidJoinClosed"))
			midJoinClosedRemote:FireAllClients()
			debugLog("Mid-join closed at halftime")
		end
	end)
end

-- End match phase → PostGame → back to Lobby
function MatchLoop.EndMatch(reason: string)
	debugLog("Match ended: " .. (reason or "unknown"))

	local GameDirector = require(script.Parent.GameDirector)
	local HUDManager = require(ServerScriptService.Modules.HUDManager)

	GameDirector._ChangeState(GameDirector.States.PostGame)

	-- Update HUD for post-game
	HUDManager.OnStateChange("PostGame")

	-- Clean up match state
	local TeamsService = require(ServerScriptService.Modules.TeamsService)
	local LoadoutService = require(ServerScriptService.Modules.LoadoutService)
	local TagService = require(ServerScriptService.Modules.TagService)

	TeamsService.MoveAllToSpectators()
	LoadoutService.RemoveAllTools()
	TagService.UnfreezeAllPlayers() -- FIXED: Use TagService instead of TagEffects

	-- Reset mid-join timing
	matchStartTime = 0
	halftimeCutoff = 0

	-- Post-game timer
	startTimer(Cfg("Round.PostGameSeconds"), function()
		if Cfg("Round.AutoRestart") then
			MatchLoop.BeginLobby()
		else
			debugLog("Auto-restart disabled")
		end
	end)
end

-- Begin lobby phase (use RunLobbyPhase for auto-loop)
function MatchLoop.BeginLobby()
	debugLog("Starting lobby phase")

	local GameDirector = require(script.Parent.GameDirector)
	local HUDManager = require(ServerScriptService.Modules.HUDManager)
	local MapService = require(ServerScriptService.Modules.MapService)

	GameDirector._ChangeState(GameDirector.States.Lobby)

	-- Set all players to spectator team
	local TeamsService = require(ServerScriptService.Modules.TeamsService)
	TeamsService.MoveAllToSpectators()

	-- Build/refresh lobby pads and respawn everyone there
	MapService.LoadLobbySpawns()
	MapService.RespawnAllToLobby()

	-- Update HUD for lobby state
	HUDManager.OnStateChange("Lobby")

	-- Run lobby loop if enabled
	if Cfg("FeatureToggles.LobbyAutoLoop") then
		MatchLoop.RunLobbyPhase()

		-- Choose mode and map after lobby phase completes
		local mode = Cfg("Voting.DefaultMode")
		local map = Cfg("Voting.DefaultMap")

		if Cfg("Voting.Enabled") then
			-- TODO: Implement voting logic
			debugLog("Voting not implemented, using defaults")
		else
			-- Random map selection if multiple maps available
			local mapOptions = Cfg("Voting.MapOptions")
			if #mapOptions > 1 then
				map = mapOptions[math.random(1, #mapOptions)]
				debugLog("Randomly selected map: " .. map)
			end
		end

		MatchLoop.BeginMatch(mode, map)
	else
		-- Original behavior - simple countdown
		startTimer(Cfg("Lobby.LobbyCountdownSeconds"), function()
			local mode = Cfg("Voting.DefaultMode")
			local map = Cfg("Voting.DefaultMap")

			if Cfg("Voting.Enabled") then
				debugLog("Voting not implemented, using defaults")
			else
				local mapOptions = Cfg("Voting.MapOptions")
				if #mapOptions > 1 then
					map = mapOptions[math.random(1, #mapOptions)]
					debugLog("Randomly selected map: " .. map)
				end
			end

			MatchLoop.BeginMatch(mode, map)
		end)
	end
end

-- Check if mid-join is allowed (before halftime)
function MatchLoop.IsMidJoinAllowed(): boolean
	if not Cfg("FeatureToggles.MidJoin") then return false end
	if matchStartTime == 0 then return false end -- Not in match

	return os.clock() < halftimeCutoff
end

-- Get remaining time
function MatchLoop.GetRemainingTime(): number
	if not currentTimer or not currentTimer.active then
		return 0
	end
	return math.max(0, currentTimer.endTime - os.clock())
end

-- State change notification (called by GameDirector)
function MatchLoop._NotifyStateChange(newState: string)
	-- hook for future use
end

return MatchLoop
