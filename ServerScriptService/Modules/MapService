--[[
SCRIPT_PATHS
  Self: ServerScriptService/Modules/MapService
  Requires:
    - ReplicatedStorage/Shared/GameConfig
    - ServerScriptService/Modules/TeamsService
  Remotes:
    - (none)
  UsesConfigKeys:
    - Voting.MapOptions
    - Debug.Enabled
    - Debug.Channels
]]

-- ServerScriptService/Modules/MapService.lua
-- Map loading and player RESPAWN routing (no teleports). Guarantees unique pad per player.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GameConfig = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Shared"):WaitForChild("GameConfig"))

local MapService = {}

-- Current loaded map
local currentMap: Model? = nil
local currentMapName: string? = nil

-- Spawn bookkeeping
local lobbySpawns: {SpawnLocation} = {}
local teamSpawns: {[string]: {SpawnLocation}} = { Tagger = {}, Player = {} }

-- Occupancy & assignment
local assignedSpawnByUserId: {[number]: SpawnLocation} = {}
local occupantBySpawn: {[SpawnLocation]: number} = {}

-- Round-robin indices so we don't always use pad #1
local nextIndex = { Lobby = 1, Tagger = 1, Player = 1 }

-- Debug logging
local function debugLog(message: string)
	if GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels, "Director") then
		print("[Director] " .. message)
	end
end

-- Utility: gather spawn pads under a container.
-- Accepts SpawnLocation OR any BasePart with "spawn" in the name (case-insensitive).
-- Non-SpawnLocation parts get a hidden SpawnLocation placed at same position.
local function collectSpawnsFrom(container: Instance, attachUnder: Instance): {SpawnLocation}
	local list: {SpawnLocation} = {}

	local function addSpawnAt(part: BasePart)
		if part:IsA("SpawnLocation") then
			table.insert(list, part)
			return
		end

		-- Create a hidden SpawnLocation at this part's position/size
		local s = Instance.new("SpawnLocation")
		s.Name = ("_AutoSpawn_%s"):format(part.Name)
		s.Anchored = true
		s.Locked = true
		s.CanCollide = true
		s.Enabled = true
		s.Neutral = true
		s.Duration = 0
		s.Transparency = 1
		s.Size = Vector3.new(6, 1, 6)
		s.CFrame = part.CFrame + Vector3.new(0, (part.Size.Y/2) + (s.Size.Y/2) + 0.1, 0)
		s.Parent = attachUnder
		table.insert(list, s)
	end

	for _, inst in ipairs(container:GetDescendants()) do
		if inst:IsA("SpawnLocation") then
			table.insert(list, inst)
		elseif inst:IsA("BasePart") then
			local n = inst.Name:lower()
			if n == "spawn" or n:match("^spawn%d*$") or n:find("spawn") then
				addSpawnAt(inst)
			end
		end
	end

	return list
end

-- Clear occupancy/assignments
local function resetOccupancy()
	assignedSpawnByUserId = {}
	occupantBySpawn = {}
	nextIndex = { Lobby = 1, Tagger = 1, Player = 1 }
end

-- Public: (Re)load lobby pads from workspace.Lobby
function MapService.LoadLobbySpawns()
	lobbySpawns = {}

	local lobby = workspace:FindFirstChild("Lobby")
	if not lobby then
		debugLog("No workspace.Lobby found")
		return
	end

	-- Put auto-created spawn pads under a helper folder in Lobby
	local helper = lobby:FindFirstChild("_AutoSpawns") or Instance.new("Folder")
	helper.Name = "_AutoSpawns"
	helper.Parent = lobby

	lobbySpawns = collectSpawnsFrom(lobby, helper)
	debugLog(("Found %d lobby spawn points"):format(#lobbySpawns))
end

-- Build team pad lists from the current map model
local function loadTeamSpawnsFromMap(mapModel: Model)
	teamSpawns = { Tagger = {}, Player = {} }

	local helper = mapModel:FindFirstChild("_AutoSpawns") or Instance.new("Folder")
	helper.Name = "_AutoSpawns"
	helper.Parent = mapModel

	local function addTeamSpawns(folderName: string, teamKey: string)
		local folder = mapModel:FindFirstChild(folderName)
		if folder then
			local pads = collectSpawnsFrom(folder, helper)
			for _, pad in ipairs(pads) do
				table.insert(teamSpawns[teamKey], pad)
			end
			debugLog(("Found %d spawns in %s"):format(#pads, folderName))
		end
	end

	-- Convention: TaggerSpawns and PlayerSpawns
	addTeamSpawns("TaggerSpawns", "Tagger")
	addTeamSpawns("PlayerSpawns", "Player")

	-- Fallback: generic "Spawns" split even-odd if team-specific folders absent
	if #teamSpawns.Tagger == 0 and #teamSpawns.Player == 0 then
		local spawnsFolder = mapModel:FindFirstChild("Spawns")
		if spawnsFolder then
			local pads = collectSpawnsFrom(spawnsFolder, helper)
			for i, pad in ipairs(pads) do
				if (i % 2) == 1 then
					table.insert(teamSpawns.Tagger, pad)
				else
					table.insert(teamSpawns.Player, pad)
				end
			end
			debugLog(("Fallback: split %d generic pads into Tagger/Player"):format(#pads))
		end
	end
end

-- Load a map by name (also rebuild team pad lists)
function MapService.LoadMap(mapName: string): boolean
	-- Validate option
	if not table.find(GameConfig.Voting.MapOptions, mapName) then
		warn("MapService: Map '" .. mapName .. "' not in MapOptions list")
		return false
	end

	local mapsFolder = ReplicatedStorage:FindFirstChild("Maps")
	if not mapsFolder then
		warn("MapService: ReplicatedStorage.Maps not found")
		return false
	end

	local mapModel = mapsFolder:FindFirstChild(mapName)
	if not mapModel then
		warn("MapService: Map '" .. mapName .. "' not found")
		return false
	end

	-- Unload current
	if currentMap then
		currentMap:Destroy()
		currentMap = nil
		currentMapName = nil
	end

	-- Clone to workspace
	local clone = mapModel:Clone()
	clone.Name = "CurrentMap"
	clone.Parent = workspace

	currentMap = clone
	currentMapName = mapName

	-- Rebuild spawns + reset occupancy
	loadTeamSpawnsFromMap(clone)
	resetOccupancy()

	debugLog("Loaded map: " .. mapName)
	return true
end

function MapService.UnloadMap()
	if currentMap then
		currentMap:Destroy()
		debugLog("Unloaded map: " .. (currentMapName or "unknown"))
	end
	currentMap = nil
	currentMapName = nil
	teamSpawns = { Tagger = {}, Player = {} }
	resetOccupancy()
end

function MapService.GetCurrentMapName(): string?
	return currentMapName
end

-- Reserve a unique pad from a list and assign it to the player
local function reservePadForPlayer(player: Player, pads: {SpawnLocation}, indexKey: string): SpawnLocation?
	if #pads == 0 then return nil end

	-- Reuse existing assignment if still valid
	local existing = assignedSpawnByUserId[player.UserId]
	if existing and existing.Parent then
		return existing
	end

	-- Start from rolling index and find a free slot
	local start = nextIndex[indexKey]
	if start < 1 or start > #pads then start = 1 end

	for i = 0, #pads - 1 do
		local idx = ((start - 1 + i) % #pads) + 1
		local pad = pads[idx]
		if pad and pad.Parent and not occupantBySpawn[pad] then
			assignedSpawnByUserId[player.UserId] = pad
			occupantBySpawn[pad] = player.UserId
			nextIndex[indexKey] = (idx % #pads) + 1
			return pad
		end
	end

	-- If all are "occupied" (e.g., more players than pads), we still assign round-robin.
	-- This keeps the game running (they'll stack in that extreme case).
	local idx = start
	local pad = pads[idx]
	assignedSpawnByUserId[player.UserId] = pad
	occupantBySpawn[pad] = player.UserId
	nextIndex[indexKey] = (idx % #pads) + 1
	return pad
end

-- Public: clear a player's reservation (called before changing their destination)
local function releasePlayerPad(player: Player)
	local existing = assignedSpawnByUserId[player.UserId]
	if existing then
		if occupantBySpawn[existing] == player.UserId then
			occupantBySpawn[existing] = nil
		end
		assignedSpawnByUserId[player.UserId] = nil
	end
end

-- === RESPawn APIs (single source of truth) ================================

-- Force the player to respawn at a specific pad list & index group
local function respawnPlayerAtPadList(player: Player, pads: {SpawnLocation}, indexKey: string)
	-- Move reservation
	releasePlayerPad(player)
	local pad = reservePadForPlayer(player, pads, indexKey)
	if not pad then
		warn(("MapService: No pads available for %s (%s)"):format(player.Name, indexKey))
		return
	end

	-- Drive spawn
	player.RespawnLocation = pad
	player:LoadCharacter()
end

-- Respawn player to lobby (unique pad)
function MapService.RespawnPlayerToLobby(player: Player)
	if #lobbySpawns == 0 then
		MapService.LoadLobbySpawns()
	end
	respawnPlayerAtPadList(player, lobbySpawns, "Lobby")
end

-- Respawn player according to their team on the current map (unique pad)
function MapService.RespawnPlayerToTeamPad(player: Player)
	if not currentMap then
		warn("MapService: No map loaded; falling back to lobby spawn")
		MapService.RespawnPlayerToLobby(player)
		return
	end

	local TeamsService = require(script.Parent.TeamsService)
	local role = TeamsService.GetPlayerRole(player)

	if role == "Tagger" then
		respawnPlayerAtPadList(player, teamSpawns.Tagger, "Tagger")
	elseif role == "Player" then
		respawnPlayerAtPadList(player, teamSpawns.Player, "Player")
	else
		-- Spectators, or nil role â†’ lobby
		MapService.RespawnPlayerToLobby(player)
	end
end

-- Bulk: respawn everyone to lobby pads
function MapService.RespawnAllToLobby()
	resetOccupancy()
	if #lobbySpawns == 0 then
		MapService.LoadLobbySpawns()
	end
	for _, p in ipairs(Players:GetPlayers()) do
		MapService.RespawnPlayerToLobby(p)
	end
	debugLog("Respawned all players to lobby pads")
end

-- Bulk: respawn everyone to their team pads on the current map
function MapService.RespawnAllToMapTeams()
	if not currentMap then
		warn("MapService: No map loaded; cannot respawn to map teams")
		return
	end
	resetOccupancy()
	for _, p in ipairs(Players:GetPlayers()) do
		MapService.RespawnPlayerToTeamPad(p)
	end
	debugLog("Respawned all players to team pads on map")
end

-- Cleanup when a player leaves
Players.PlayerRemoving:Connect(function(player)
	releasePlayerPad(player)
end)

return MapService
