-- Handles welded, non-colliding hitbox Parts per character
-- Game.ReplicatedStorage.Modules.MovementSystemV7.HitboxManager (ModuleScript)

local HitboxManager = {}
local PhysicsService = game:GetService("PhysicsService")
local CollectionService = game:GetService("CollectionService")
local Config = require(script.Parent.Config)

-- Store hitboxes per character
local characterHitboxes = {}

-- Ensure collision group exists (client-safe)
local function ensureCollisionGroup()
	local groupName = Config.Hitbox.CollisionGroup or "Hitboxes"

	-- On client, we can't create collision groups, so just return the name
	-- The server should handle collision group creation if needed
	if game:GetService("RunService"):IsClient() then
		return groupName
	end

	-- Server-side collision group management
	local success, _ = pcall(function()
		PhysicsService:GetCollisionGroupId(groupName)
	end)

	if not success then
		-- Use new API
		PhysicsService:RegisterCollisionGroup(groupName)
		-- Make it not collide with Default (world)
		PhysicsService:CollisionGroupSetCollidable(groupName, "Default", false)
	end

	return groupName
end

-- Create and configure hitbox part
local function createHitbox(character)
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return nil end

	local hitbox = Instance.new("Part")
	hitbox.Name = "Hitbox"
	hitbox.Size = Config.Hitbox.Size or Vector3.new(4, 6, 4)
	hitbox.CanCollide = false
	hitbox.CanTouch = true
	hitbox.CanQuery = true
	hitbox.Massless = true
	hitbox.Transparency = 0.5  -- Make it temporarily visible for debugging
	hitbox.BrickColor = BrickColor.new("Bright blue")  -- Blue color for debugging
	hitbox.Anchored = false
	hitbox.Material = Enum.Material.ForceField

	-- Set collision group (using new API)
	local groupName = ensureCollisionGroup()
	local success = pcall(function()
		hitbox.CollisionGroup = groupName
	end)

	-- If setting collision group fails on client, that's okay - the hitbox is still non-colliding
	if not success and game:GetService("RunService"):IsServer() then
		warn("Failed to set collision group for hitbox")
	end

	-- Tag for debugging
	CollectionService:AddTag(hitbox, "CharacterHitbox")

	-- IMPORTANT: Parent AFTER setting properties but BEFORE positioning and welding
	hitbox.Parent = character

	-- Apply offset positioning - use default offset of (0, 0, 0) to center it first
	local offset = Config.Hitbox.Offset or Vector3.new(0, 0, 0)  -- Changed default to center
	hitbox.CFrame = rootPart.CFrame * CFrame.new(offset)

	-- Create weld constraint immediately after positioning
	local weld = Instance.new("WeldConstraint")
	weld.Name = "HitboxWeld"
	weld.Part0 = rootPart
	weld.Part1 = hitbox
	weld.Parent = hitbox

	print("Hitbox created and welded. RootPart pos:", rootPart.Position, "Hitbox pos:", hitbox.Position, "Offset used:", offset)

	return hitbox
end

-- Rebuild weld constraint with new offset
local function rebuildWeld(hitbox, rootPart, offset)
	-- Destroy existing weld
	local existingWeld = hitbox:FindFirstChild("HitboxWeld")
	if existingWeld then
		existingWeld:Destroy()
	end

	-- Position hitbox with offset BEFORE creating weld
	hitbox.CFrame = rootPart.CFrame * CFrame.new(offset)

	-- Wait a frame to ensure positioning is applied
	game:GetService("RunService").Heartbeat:Wait()

	-- Create new weld constraint
	local weld = Instance.new("WeldConstraint")
	weld.Name = "HitboxWeld"
	weld.Part0 = rootPart
	weld.Part1 = hitbox
	weld.Parent = hitbox
end

-- API Functions
function HitboxManager:Attach(character)
	if not Config.Hitbox.Enabled then return nil end

	-- Return existing if already cached
	if characterHitboxes[character] then
		return characterHitboxes[character]
	end

	local hitbox = createHitbox(character)
	if hitbox then
		characterHitboxes[character] = hitbox

		-- Clean up when character is removed
		character.AncestryChanged:Connect(function()
			if not character.Parent then
				self:Detach(character)
			end
		end)
	end

	return hitbox
end

function HitboxManager:Detach(character)
	local hitbox = characterHitboxes[character]
	if hitbox then
		-- Remove tag
		CollectionService:RemoveTag(hitbox, "CharacterHitbox")

		-- Destroy hitbox (weld will be destroyed with it)
		hitbox:Destroy()
		characterHitboxes[character] = nil
	end
end

function HitboxManager:Get(character)
	return characterHitboxes[character]
end

function HitboxManager:Resize(character, size, offset)
	local hitbox = characterHitboxes[character]
	if not hitbox then return end

	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end

	-- Update size
	hitbox.Size = size

	-- If offset provided, rebuild weld to bake in new offset
	if offset then
		rebuildWeld(hitbox, rootPart, offset)
	end
end

-- Cleanup on player leaving
game.Players.PlayerRemoving:Connect(function(player)
	if player.Character and characterHitboxes[player.Character] then
		HitboxManager:Detach(player.Character)
	end
end)

return HitboxManager
