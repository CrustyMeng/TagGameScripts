-- ReplicatedStorage/Modules/Game/TagService.lua
-- Universal tag validation and event handling

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GameConfig = require(script.Parent.GameConfig)

local TagService = {}

-- Create tag event signal
local taggedEvent = Instance.new("BindableEvent")
TagService.Tagged = taggedEvent.Event

-- Debug logging
local function debugLog(message: string)
	if GameConfig.Debug.Enabled and table.find(GameConfig.Debug.Channels, "Tag") then
		print("[Tag] " .. message)
	end
end

-- Validate if a tag is allowed
local function validateTag(attacker: Player, victim: Player): (boolean, string?)
	-- Check if match is running
	local GameDirector = require(game:GetService("ServerScriptService").Modules.GameDirector)
	if GameDirector.GetState() ~= GameDirector.States.Match then
		return false, "Match not active"
	end

	-- Check if both players exist
	if not attacker or not attacker.Parent then
		return false, "Invalid attacker"
	end
	if not victim or not victim.Parent then
		return false, "Invalid victim"  
	end

	-- Check if both have characters
	if not attacker.Character or not victim.Character then
		return false, "Missing character"
	end

	local attackerRoot = attacker.Character:FindFirstChild("HumanoidRootPart")
	local victimRoot = victim.Character:FindFirstChild("HumanoidRootPart")

	if not attackerRoot or not victimRoot then
		return false, "Missing HumanoidRootPart"
	end

	-- Check distance
	local distance = (attackerRoot.Position - victimRoot.Position).Magnitude
	if distance > GameConfig.Tagging.MaxRange then
		return false, "Too far (" .. math.floor(distance) .. " > " .. GameConfig.Tagging.MaxRange .. ")"
	end

	-- Check friendly fire
	if not GameConfig.Tagging.FriendlyFire then
		local TeamsService = require(script.Parent.TeamsService)
		local attackerRole = TeamsService.GetPlayerRole(attacker)
		local victimRole = TeamsService.GetPlayerRole(victim)

		if attackerRole == victimRole then
			return false, "Friendly fire disabled"
		end
	end

	return true
end

-- Report a tag attempt from client/server
function TagService.ReportTag(attacker: Player, victim: Player, payload: table?)
	local valid, reason = validateTag(attacker, victim)

	if not valid then
		debugLog("Tag rejected: " .. attacker.Name .. " → " .. victim.Name .. " (" .. (reason or "unknown") .. ")")
		return false
	end

	-- Tag is valid, fire event
	debugLog("Tag confirmed: " .. attacker.Name .. " → " .. victim.Name)
	taggedEvent:Fire(attacker, victim, payload)

	return true
end

-- Set up remote events for client communication
local function setupRemotes()
	local remotes = ReplicatedStorage:FindFirstChild("Remotes")
	if not remotes then
		remotes = Instance.new("Folder")
		remotes.Name = "Remotes"
		remotes.Parent = ReplicatedStorage
	end

	-- Create tag remote if it doesn't exist
	local tagRemote = remotes:FindFirstChild("ReportTag")
	if not tagRemote then
		tagRemote = Instance.new("RemoteEvent")
		tagRemote.Name = "ReportTag"
		tagRemote.Parent = remotes

		-- Handle tag reports from clients
		tagRemote.OnServerEvent:Connect(function(player, victimPlayer, payload)
			if typeof(victimPlayer) ~= "Instance" or not victimPlayer:IsA("Player") then
				return
			end
			TagService.ReportTag(player, victimPlayer, payload)
		end)
	end
end

-- Initialize the service immediately (not in task.spawn)
setupRemotes()

return TagService
